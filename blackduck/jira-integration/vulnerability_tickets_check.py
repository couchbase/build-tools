#!/usr/bin/env python3

import re
import argparse
import logging
import sys
import time
import timestring
from jira_issue_manager import JiraIssueManager
import constants
from blackduck_client import BlackduckClient

logging.basicConfig(
    format='%(asctime)s:%(levelname)s:%(message)s',
    stream=sys.stderr,
    level=logging.INFO
)

def is_scan_completed(blackduck_client, version):
    ''' Check if Blackduck scan has completed. '''
    for _ in range(60):
        result = blackduck_client.get_bom_status(version)
        bom_status = result.get('status')
        if 'PROCESSING' in bom_status:
            logging.info('Waiting for Blackduck scan to finish...')
            time.sleep(60)
        else:
            return timestring.Date(result.get('lastScanDate')).date
    logging.error('A scan has been running for more than an hour. Timeout.')
    sys.exit(1)

def categorize_scan_results(bom_vuln_entries, issues):
    ''' Categorize vulnerability entries into tickets to close, update, and open. '''
    ticket_close_list = []
    ticket_update_list = []
    ticket_open_list = []

    issue_map = {(issue['fields'][constants.BD_COMPONENT_FIELD].lower(
    ), issue['fields'][constants.BD_COMPONENT_VERSION_FIELD].lower()): issue for issue in issues}
    component_map = {
        (component['componentName'].lower(), component['componentVersionName'].lower()): component
        for component in bom_vuln_entries
    }

    for comp in bom_vuln_entries:
        key = (comp['componentName'].lower(),
               comp['componentVersionName'].lower())
        issue = issue_map.get(key)

        if issue:
            if (issue['fields'][constants.BD_SEVERITY_FIELD] != comp['severity'] or
                sorted(re.split(',', str(issue['fields'][constants.BD_CVES_FIELD]))) !=
                sorted(re.split(',', comp['cves']))):
                ticket_info = {}
                ticket_info['updated_fields'] = comp
                ticket_info['jira_key'] = issue['key']
                ticket_update_list.append(ticket_info)
        else:
            ticket_open_list.append(comp)

    ticket_close_list = [issue for issue in issues
                         if (issue['fields'][constants.BD_COMPONENT_FIELD].lower(),
                             issue['fields'][constants.BD_COMPONENT_VERSION_FIELD].lower())
                             not in component_map]
    return ticket_close_list, ticket_update_list, ticket_open_list

def updated_ticket_fields(issue, bom_vuln_updates):
    ''' Update issue fields with new vulnerability information. '''
    updated_fields = bom_vuln_updates.copy()
    issue_cves = re.split(
        ',', getattr(issue.fields, constants.BD_CVES_FIELD))
    bom_cves = re.split(',', bom_vuln_updates.get('cves', ''))
    updated_fields['cves'] = ','.join(sorted(set(issue_cves + bom_cves)))
    updated_fields['severity'] = max(
        [getattr(issue.fields, constants.BD_SEVERITY_FIELD), bom_vuln_updates.get('severity')],
        key=lambda s: constants.SEVERITY_LIST.index(s)
    )

    links = re.split('{anchor}', getattr(issue.fields, constants.BD_DETAIL_FIELD))[
        1].splitlines()
    bom_links = bom_vuln_updates.get('links', '').splitlines()
    updated_fields['links'] = '\n'.join(
        set(link for link in links + bom_links if link))
    return updated_fields

def close_ticket(issue):
    ''' Close the JIRA ticket if it's not in an excluded status. '''
    status = issue.fields.status.name
    key = issue.key
    if status not in constants.DONE_STATUSES:
        logging.info(f'Closing ticket: {key}')
        jira.transition_issue(
            issue,
            constants.WORKFLOW_DONE_ID,
            {}
        )
        jira.client.add_comment(issue, 'Mark ticket as done. Removed by Blackduck Hub.')

def reopen_ticket(issue):
    ''' Reopen a ticket. '''
    status = issue.fields.status.name
    severity = getattr(issue.fields, constants.BD_SEVERITY_FIELD)
    key = issue.key
    if (status not in constants.DO_NOT_REOPEN_STATUSES and
        severity != 'LOW'):
        logging.info(f'Reopen ticket: {key}')
        jira.transition_issue(
            issue,
            constants.WORKFLOW_TO_DO_ID,
            {}
        )
        jira.client.add_comment(issue, f'{key} is reopened since CVE(s) was updated or added.')

def create_ticket(issue_info, project_name, version_name):
    '''
    Create a new Jira ticket
    associate it with tickets of the same 3rd party library
    '''
    related_issues = jira.search_related_issues(issue_info['componentName'],
                                                issue_info['componentVersionName'],
                                                project_name
                                                )
    issue = jira.new_issue(issue_info, project_name, version_name)
    logging.info(f'Created ticket: {issue.key}')
    if getattr(issue.fields, constants.BD_SEVERITY_FIELD) == 'LOW':
        jira.transition_issue(
            issue,
            constants.WORKFLOW_DONE_ID,
            {}
        )
        jira.client.add_comment(issue, f'{issue.key} is automatically closed due to low severity.')
    if related_issues:
        for r in related_issues:
            logging.info(f'Link {issue.key} with {r.key}')
            jira.create_issue_link(issue.key, r.key)

def process_scan_changes(jira, bom_vulnerabilities, existing_issues, project_name, version_name):
    ''' Update JIRA tickets based on scan results from Blackduck. '''
    tickets_need_close, tickets_need_update, tickets_need_open = categorize_scan_results(
        bom_vulnerabilities, existing_issues)

    for ticket_info in tickets_need_close:
        issue = jira.client.issue(ticket_info['key'])
        close_ticket(issue)

    for ticket_info in tickets_need_open:
        logging.info(
            f"Open new ticket for {ticket_info['componentName']}:"
            f"{ticket_info['componentVersionName']}")
        create_ticket(ticket_info, project_name, version_name)

    for ticket_info in tickets_need_update:
        updates = ticket_info['updated_fields']
        issue = jira.client.issue(ticket_info['jira_key'])
        jira.update_issue(issue, updates, project_name, version_name)
        reopen_ticket(issue)

def process_knowledgebase_changes(
        jira,
        tickets_need_update,
        tickets_need_close,
        project_name,
        version_name):
    ''' Update JIRA tickets based on changes from Blackduck knowledgebase. '''
    for t in tickets_need_close:
        logging.debug(f"Does {t['componentName']}:{t['componentVersionName']} exist in Jira?")
        issue = jira.search_issue(
            t['componentName'],
            t['componentVersionName'],
            project_name,
            version_name)
        if issue:
            close_ticket(issue)

    for t in tickets_need_update:
        issue = jira.search_issue(
            t['componentName'],
            t['componentVersionName'],
            project_name,
            version_name)
        if issue:
            updates = updated_ticket_fields(issue, t)
            logging.info(f'Update ticket, {issue.key}')
            jira.update_issue(issue, updates, project_name, version_name)
            reopen_ticket(issue)
        else:
            logging.info(
                f"Create new issue for {t['componentName']}:{t['componentVersionName']}")
            create_ticket(t, project_name, version_name)


# Main execution
parser = argparse.ArgumentParser(
    'Create or update JIRA tickets based on Blackduck vulnerabilities')
subparsers = parser.add_subparsers(
    help='Blackduck vulnerability types: scan or knowledgebase.',
    dest='type')
scan_parser = subparsers.add_parser('scan')
knowledgebase_parser = subparsers.add_parser('knowledgebase')

scan_parser.add_argument(
    '-p',
    '--project_name',
    required=True,
    help='Project name in Blackduck.')
scan_parser.add_argument(
    '-v',
    '--version_name',
    required=True,
    help='Project version.')
knowledgebase_parser.add_argument(
    '-d',
    '--start_date',
    required=True,
    help='Start date of knowledgebase activities')

args = parser.parse_args()

blackduck = BlackduckClient()
jira = JiraIssueManager()

if args.type == 'scan':
    current_issues = jira.find_project_version_issues(
        args.project_name, args.version_name)
    logging.info(f'Checking {args.project_name} {args.version_name} BOM vulnerabilities against Jira.')
    project = blackduck.hub.get_project_by_name(args.project_name)
    version = blackduck.hub.get_version_by_name(project, args.version_name)
    last_scan_date = is_scan_completed(blackduck, version)
    bom_vulns = blackduck.prepare_vulnerability_entries(version)
    process_scan_changes(jira, bom_vulns, current_issues, args.project_name, args.version_name)

if args.type == 'knowledgebase':
    start_date = timestring.Date(args.start_date).date
    projects = blackduck.hub.get_projects()
    for project in projects.get('items'):
        # Skip the projects that we don't or no longer maintain
        if project['name'] in constants.EXCLUDED_PROJECTS:
            continue
        logging.info(f"Checking Blackduck Hub updates for {project['name']}")
        versions = blackduck.hub.get_project_versions(project, limit=999)
        if versions.get('totalCount') != 0:
            for version in versions.get('items'):
                version_name = version.get('versionName')
                # Skip snapshot, beta, and other invalid versions
                if re.search(r'[^0-9.]', version_name):
                    logging.info(f'Skip {version_name}')
                    continue
                logging.info(f'Checking version {version_name}')
                last_scan_date = is_scan_completed(blackduck, version)
                if last_scan_date > start_date:
                    start_date = last_scan_date
                    logging.info('Last scan date is newer.  Only looks for changes since then.')
                tickets_to_update, tickets_to_close = blackduck.get_version_journal(
                    version, start_date)
                process_knowledgebase_changes(
                    jira,
                    tickets_to_update,
                    tickets_to_close,
                    project['name'],
                    version_name)
