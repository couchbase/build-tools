#!/usr/bin/env python3

import re
import argparse
import logging
import sys
import time
import timestring
from jira_issue_manager import JiraIssueManager
import constants
from blackduck_client import BlackduckClient

logging.basicConfig(
    format='%(asctime)s:%(levelname)s:%(message)s',
    level=logging.INFO
)


def is_scan_completed(blackduck_client, version):
    ''' Check if Blackduck scan has completed. '''
    for _ in range(60):
        result = blackduck_client.get_bom_status(version)
        bom_status = result.get('status')
        if 'PROCESSING' in bom_status:
            logging.info('Waiting for Blackduck scan to finish...')
            time.sleep(60)
        else:
            return timestring.Date(result.get('lastScanDate')).date
    logging.error('A scan has been running for more than an hour. Timeout.')
    sys.exit(1)


def categorize_scan_results(bom_vuln_entries, issues):
    ''' Categorize vulnerability entries into tickets to close, update, and open. '''
    ticket_close_list = []
    ticket_update_list = []
    ticket_open_list = []

    issue_map = {(issue['fields'][constants.BD_COMPONENT_FIELD].lower(
    ), issue['fields'][constants.BD_COMPONENT_VERSION_FIELD].lower()): issue for issue in issues}
    component_map = {
        (component['componentName'].lower(), component['componentVersionName'].lower()): component
        for component in bom_vuln_entries
    }

    for comp in bom_vuln_entries:
        key = (comp['componentName'].lower(),
               comp['componentVersionName'].lower())
        issue = issue_map.get(key)
        logging.debug(
            f'Checking component: {comp["componentName"]}:{comp["componentVersionName"]}')

        if issue:
            logging.debug(f'Found existing issue: {issue["key"]}')
            if (issue['fields'][constants.BD_SEVERITY_FIELD] != comp['severity'] or
                sorted(re.split(',', str(issue['fields'][constants.BD_CVES_FIELD]))) !=
                    sorted(re.split(',', comp['cves']))):
                logging.debug(
                    f'Issue {issue["key"]} needs update - severity or CVEs changed')
                ticket_info = {}
                ticket_info['updated_fields'] = comp
                ticket_info['jira_key'] = issue['key']
                ticket_update_list.append(ticket_info)
            elif issue['fields']['status']['name'] == 'Done':
                logging.debug('Component reappeared. '
                              f'Issue {issue["key"]} needs to be reopened')
                # 03-04-2025, VULN Jira project is changed so that Done status is
                # used exclusively by automation.  The ticket is transitioned to
                # 'Done' when a vulnerable component is not detected by scan.
                # If it shows up on BD scan again, the ticket needs to be
                # reopened.
                ticket_info = {}
                ticket_info['updated_fields'] = comp
                ticket_info['jira_key'] = issue['key']
                ticket_update_list.append(ticket_info)
            else:
                logging.debug(f'Issue {issue["key"]} is up to date')
        else:
            logging.debug(
                f'No issue is found for {comp["componentName"]}:{comp["componentVersionName"]}. '
                'Needs to open a new ticket')
            ticket_open_list.append(comp)

    ticket_close_list = [issue for issue in issues
                         if (issue['fields'][constants.BD_COMPONENT_FIELD].lower(),
                             issue['fields'][constants.BD_COMPONENT_VERSION_FIELD].lower())
                         not in component_map]

    return ticket_close_list, ticket_update_list, ticket_open_list


def updated_ticket_fields(issue, bom_vuln_updates):
    ''' Update issue fields with new vulnerability information. '''
    updated_fields = bom_vuln_updates.copy()
    issue_cves = re.split(
        ',', getattr(issue.fields, constants.BD_CVES_FIELD, '') or '')
    bom_cves = re.split(
        ',', bom_vuln_updates.get('cves', '') or '')
    updated_fields['cves'] = ','.join(
        sorted({cve for cve in issue_cves + bom_cves if cve}))
    updated_fields['severity'] = min(
        [getattr(issue.fields, constants.BD_SEVERITY_FIELD),
         bom_vuln_updates.get('severity')],
        key=lambda s: constants.SEVERITY_LIST.index(s)
    )

    # Extract existing links from the BD_DETAIL_FIELD - handle missing {anchor} tags gracefully
    detail_field = getattr(issue.fields, constants.BD_DETAIL_FIELD, '') or ''
    anchor_split = re.split('{anchor}', detail_field)

    # If index 1 is present (vulnerability links) - use that
    if len(anchor_split) >= 2:
        links = anchor_split[1].splitlines()
    else:
        logging.debug(f'BD_DETAIL_FIELD for {getattr(issue, "key", "unknown")} does not contain {{anchor}} tags')
        links = []

    bom_links = bom_vuln_updates.get('links', '').splitlines()
    updated_fields['links'] = '\n'.join(
        set(link for link in links + bom_links if link))
    return updated_fields


def close_ticket(issue, source, dry_run):
    ''' Close the JIRA ticket if it's not in an excluded status. '''
    status = issue.fields.status.name
    key = issue.key
    comment = ''
    if source == 'scan':
        comment = 'Mark ticket as done. Blackduck scan no longer detects this vulnerable component.'
    elif source == 'knowledgebase':
        comment = 'Mark ticket as done. Vulnerable component removed by Blackduck knowledgebase update.'

    if status not in constants.DONE_STATUSES:
        if dry_run:
            logging.info(f'{issue.key} would be closed')
        else:
            logging.info(f'Closing ticket: {key}')
            jira.transition_issue(
                issue,
                constants.WORKFLOW_DONE_ID,
                {}
            )
            jira.client.add_comment(
                issue, comment)
    else:
        logging.debug(f'{issue.key} is already in a "Done" state')


def reopen_ticket(issue):
    ''' Reopen a ticket. '''
    summary = issue.fields.summary
    key = issue.key
    logging.info(f'Reopening ticket: {key}')
    jira.transition_issue(
        issue,
        constants.WORKFLOW_TO_DO_ID,
        {}
    )
    jira.client.add_comment(
        issue,
        f'{key} is reopened.  Either CVE(s) has changed, or {summary} is reintroduced')


def should_reopen_ticket(issue, updates):
    '''
    Determine if a ticket should be reopened.  Don't reopen if:
    * Issue in excluded status
    * Severity is low
    * only CVEs removed
    '''
    logging.debug(f'Evaluating if ticket {issue.key} should be reopened')

    # Get current and new values
    status = issue.fields.status.name
    old_cves = getattr(issue.fields, constants.BD_CVES_FIELD, '')
    new_cves = updates.get('cves', '')
    old_severity = getattr(issue.fields, constants.BD_SEVERITY_FIELD)
    # Default to old severity if not present
    new_severity = updates.get('severity', old_severity)

    # compare new and old cves
    # if no new cve and only removed cve, return False
    old_cve_set = set(cve for cve in re.split(',', old_cves or '') if cve)
    new_cve_set = set(cve for cve in re.split(',', new_cves or '') if cve)
    added_cves = new_cve_set - old_cve_set
    removed_cves = old_cve_set - new_cve_set

    logging.debug(f'Status: {status}')
    logging.debug(f'Old CVEs: {old_cves}')
    logging.debug(f'New CVEs: {new_cves}')
    logging.debug(f'Old severity: {old_severity}')
    logging.debug(f'New severity: {new_severity}')
    logging.debug(f'Added CVEs: {added_cves}')
    logging.debug(f'Removed CVEs: {removed_cves}')

    if not added_cves and removed_cves:
        logging.debug('No new CVEs and only removed CVEs. '
                      f'{issue.key} will not be reopened')
        return False

    # if ticket is in excluded status or severity is low, return False
    if (status in constants.DO_NOT_REOPEN_STATUSES or
            new_severity == 'LOW'):
        logging.debug('Ticket is in excluded status or severity is low. '
                      f'{issue.key} will not be reopened')
        return False

    logging.debug(f'{issue.key} will be reopened')
    return True


def create_ticket(issue_info, project_name, version_name, dry_run):
    '''
    Create a new Jira ticket
    associate it with tickets of the same 3rd party library
    '''
    if dry_run:
        logging.info('A new ticket would be opened for '
            f'{project_name} {version_name}')
        return

    related_issues = jira.search_related_issues(issue_info['componentName'],
                                                issue_info['componentVersionName'],
                                                project_name
                                                )
    issue = jira.new_issue(issue_info, project_name, version_name)
    logging.info(f'Created ticket: {issue.key}')
    if getattr(issue.fields, constants.BD_SEVERITY_FIELD) == 'LOW':
        jira.transition_issue(
            issue,
            constants.WORKFLOW_DONE_ID,
            {}
        )
        jira.client.add_comment(
            issue, f'{issue.key} is automatically closed due to low severity.')
    if related_issues:
        for r in related_issues:
            logging.info(f'Link {issue.key} with {r.key}')
            jira.create_issue_link(issue.key, r.key)


def process_scan_changes(jira, bom_vulnerabilities,
                         existing_issues, project_name, version_name, dry_run):
    ''' Update JIRA tickets based on scan results from Blackduck. '''
    logging.debug(f'Processing scan changes for {project_name}:{version_name}')

    tickets_need_close, tickets_need_update, tickets_need_open = categorize_scan_results(
        bom_vulnerabilities, existing_issues)
    for ticket_info in tickets_need_close:
        issue = jira.client.issue(ticket_info['key'])
        close_ticket(issue, 'scan', dry_run)

    for ticket_info in tickets_need_open:
        logging.info(
            f'Open new ticket for {ticket_info["componentName"]}:'
            f'{ticket_info["componentVersionName"]}')
        create_ticket(ticket_info, project_name, version_name, dry_run)

    for ticket_info in tickets_need_update:
        updates = ticket_info['updated_fields']
        issue = jira.client.issue(ticket_info['jira_key'])
        logging.info(f'Updating ticket {issue.key}')
        logging.debug(f'Update details: {updates}')
        if not dry_run:
            jira.update_issue(issue, updates, project_name, version_name)
            if should_reopen_ticket(issue, updates):
                reopen_ticket(issue)


def process_knowledgebase_changes(
        jira,
        tickets_need_update,
        tickets_need_close,
        project_name,
        version_name,
        dry_run):
    ''' Update JIRA tickets based on changes from Blackduck knowledgebase. '''
    for t in tickets_need_close:
        logging.debug(
            f'Does {t["componentName"]}:{t["componentVersionName"]} exist in Jira?')
        issue = jira.search_issue(
            t['componentName'],
            t['componentVersionName'],
            project_name,
            version_name)
        close_ticket(issue, 'knowledgebase', dry_run)

    for t in tickets_need_update:
        logging.debug(
            f'need to update {t["componentName"]}:{t["componentVersionName"]} in Jira')
        issue = jira.search_issue(
            t['componentName'],
            t['componentVersionName'],
            project_name,
            version_name)
        if issue:
            updates = updated_ticket_fields(issue, t)
            logging.info(f'Update ticket, {issue.key}')
            logging.debug(f'Update details: {updates}')
            if not dry_run:
                jira.update_issue(issue, updates, project_name, version_name)
                if should_reopen_ticket(issue, updates):
                    reopen_ticket(issue)
        else:
            logging.info(f'Open new ticket for {project_name}:{version_name}')
            create_ticket(t, project_name, version_name, dry_run)


# Main execution
parser = argparse.ArgumentParser(
    'Create or update JIRA tickets based on Blackduck vulnerabilities')
subparsers = parser.add_subparsers(
    help='Blackduck vulnerability types: scan or knowledgebase.',
    dest='type')
scan_parser = subparsers.add_parser('scan')
knowledgebase_parser = subparsers.add_parser('knowledgebase')

scan_parser.add_argument(
    '-p',
    '--project_name',
    required=True,
    help='Project name in Blackduck.')
scan_parser.add_argument(
    '-v',
    '--version_name',
    required=True,
    help='Project version.')
scan_parser.add_argument(
    '--dry-run',
    action='store_true',
    default=False,
    help='Preview changes without making actual modifications to JIRA tickets.')
scan_parser.add_argument(
    '--debug',
    action='store_true',
    default=False,
    help='Enable debug logging for detailed output.')

knowledgebase_parser.add_argument(
    '-d',
    '--start_date',
    required=True,
    help='Start date of knowledgebase activities')
knowledgebase_parser.add_argument(
    '--dry-run',
    action='store_true',
    default=False,
    help='Preview changes without making actual modifications to JIRA tickets.')
knowledgebase_parser.add_argument(
    '--debug',
    action='store_true',
    default=False,
    help='Enable debug logging for detailed output.')

args = parser.parse_args()

if not hasattr(args, 'type') or args.type is None:
    parser.print_help()
    sys.exit(1)

# Configure logging level based on debug flag
if args.debug:
    logging.getLogger().setLevel(logging.DEBUG)
    logging.debug("Debug logging enabled")

if args.dry_run:
    logging.info(
        'DRY RUN MODE: No actual changes will be made to JIRA tickets')

blackduck = BlackduckClient()
jira = JiraIssueManager()

if args.type == 'scan':
    logging.debug(f'Scanning {args.project_name}:{args.version_name}')
    logging.info(
        f'Checking {args.project_name} {args.version_name} BOM vulnerabilities against Jira')
    project = blackduck.get_project_by_name(args.project_name)
    version = blackduck.get_project_version(project, args.version_name)
    # Check if version is archived - skip scanning if it is
    if blackduck.is_version_archived(version):
        logging.info(f'Skipping scan for archived version: {args.project_name}:{args.version_name}')
        sys.exit(0)
    last_scan_date = is_scan_completed(blackduck, version)
    logging.debug(f'Last scan completed on: {last_scan_date}')
    bom_vulns = blackduck.prepare_vulnerability_entries(version)
    current_issues = jira.find_project_version_issues(
        args.project_name, args.version_name)

    process_scan_changes(
        jira,
        bom_vulns,
        current_issues,
        args.project_name,
        args.version_name,
        args.dry_run)

if args.type == 'knowledgebase':
    logging.debug(
        f'Checking VULN based on Blackduck activity journal from date: {args.start_date}')
    start_date = timestring.Date(args.start_date).date
    params = {'limit': '0'}
    projects = blackduck.hub_client.get_resource('projects')
    for project in projects:
        # Skip the projects that we don't or no longer maintain
        if project['name'] in constants.EXCLUDED_PROJECTS:
            logging.debug(f'Skipping excluded project: {project["name"]}')
            continue
        logging.info(f'Checking Blackduck Hub updates for {project["name"]}')
        versions = blackduck.hub_client.get_resource(
            'versions', parent=project, params=params)
        if versions is not None:
            for version in versions:
                version_name = version.get('versionName')
                logging.debug(f'Processing version: {version_name}')

                # Process if the version is on INCLUDED_VERSION_NAMES
                # or is a numeric version
                if (version_name.lower() not in constants.INCLUDED_VERSION_NAMES and
                    re.search(r'[^0-9.]', version_name)):
                    logging.info(f"Skip {version_name}.  We don't plan to tracked it in Jira")
                    continue
                # Skip archived versions
                if blackduck.is_version_archived(version):
                    logging.info(f'Skipping archived version: {project["name"]}:{version_name}')
                    continue

                logging.info(f'Checking version {version_name}')
                last_scan_date = is_scan_completed(blackduck, version)
                if last_scan_date > start_date:
                    logging.info(
                        f'Last scan, {last_scan_date} is newer than {start_date} '
                        f'for {version_name}.  Skip checking against Jira')
                    continue
                tickets_to_update, tickets_to_close = blackduck.get_version_journal(
                    version, start_date)
                process_knowledgebase_changes(
                    jira,
                    tickets_to_update,
                    tickets_to_close,
                    project['name'],
                    version_name,
                    args.dry_run)
        else:
            logging.debug(f'No versions found for project {project["name"]}')
